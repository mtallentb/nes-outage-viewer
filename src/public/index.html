<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NES Outage Dashboard</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      color: #eee;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      background: #16213e;
      padding: 16px 24px;
      border-bottom: 1px solid #0f3460;
    }

    .header-top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    h1 {
      font-size: 1.5rem;
      font-weight: 600;
      color: #fff;
    }

    .auto-refresh {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.875rem;
    }

    .auto-refresh label {
      cursor: pointer;
    }

    .toggle {
      position: relative;
      width: 44px;
      height: 24px;
    }

    .toggle input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #444;
      border-radius: 24px;
      transition: 0.3s;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      border-radius: 50%;
      transition: 0.3s;
    }

    .toggle input:checked + .toggle-slider {
      background-color: #4ade80;
    }

    .toggle input:checked + .toggle-slider:before {
      transform: translateX(20px);
    }

    .metrics-row {
      display: flex;
      gap: 24px;
      font-size: 0.875rem;
      color: #aaa;
      flex-wrap: wrap;
    }

    .metrics-group {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .metrics-label {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #666;
    }

    .metrics-values {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .metrics-values strong {
      color: #fff;
      font-weight: 600;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      display: inline-block;
    }

    .status-dot.assigned {
      background: #4ade80;
    }

    .status-dot.unassigned {
      background: #f87171;
    }

    .divider {
      color: #444;
    }

    .inline-input {
      width: 90px;
      padding: 4px 8px;
      background: #0f3460;
      border: 1px solid #1e4976;
      border-radius: 4px;
      color: #fff;
      font-size: 0.8rem;
    }

    .inline-input.radius {
      width: 50px;
    }

    .inline-input:focus {
      outline: none;
      border-color: #3b82f6;
    }

    .address-group {
      flex-shrink: 0;
    }

    .address-wrapper {
      position: relative;
    }

    .address-input {
      width: 200px;
    }

    .address-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: #0f3460;
      border: 1px solid #1e4976;
      border-top: none;
      border-radius: 0 0 4px 4px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 1000;
    }

    .address-dropdown.hidden {
      display: none;
    }

    .address-option {
      padding: 8px 10px;
      cursor: pointer;
      font-size: 0.8rem;
      border-bottom: 1px solid #1e4976;
    }

    .address-option:last-child {
      border-bottom: none;
    }

    .address-option:hover {
      background: #1e4976;
    }

    .address-option-main {
      color: #fff;
    }

    .address-option-secondary {
      color: #888;
      font-size: 0.7rem;
      margin-top: 2px;
    }


    #map {
      flex: 1;
      width: 100%;
    }

    .legend {
      position: absolute;
      bottom: 24px;
      left: 24px;
      background: rgba(22, 33, 62, 0.95);
      padding: 12px 16px;
      border-radius: 8px;
      z-index: 1000;
      font-size: 0.8rem;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
    }

    .legend-item:last-child {
      margin-bottom: 0;
    }

    .legend-marker {
      width: 14px;
      height: 14px;
      border-radius: 50%;
    }

    .legend-marker.home {
      background: #3b82f6;
      border: 2px solid #fff;
    }

    .legend-marker.assigned {
      background: #4ade80;
    }

    .legend-marker.unassigned {
      background: #f87171;
    }

    .leaflet-popup-content-wrapper {
      background: #16213e;
      color: #eee;
      border-radius: 8px;
    }

    .leaflet-popup-tip {
      background: #16213e;
    }

    .leaflet-popup-content {
      margin: 12px 16px;
    }

    .popup-title {
      font-weight: 600;
      font-size: 1rem;
      margin-bottom: 8px;
      color: #fff;
    }

    .popup-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 4px;
      font-size: 0.85rem;
    }

    .popup-label {
      color: #888;
    }

    .popup-value {
      color: #eee;
    }

    .popup-value.assigned {
      color: #4ade80;
    }

    .popup-value.unassigned {
      color: #f87171;
    }

    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1000;
      background: rgba(22, 33, 62, 0.95);
      padding: 24px 32px;
      border-radius: 12px;
      text-align: center;
    }

    .spinner {
      width: 32px;
      height: 32px;
      border: 3px solid #444;
      border-top-color: #4ade80;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 12px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Marker cluster styles for dark theme */
    .marker-cluster {
      background-clip: padding-box;
      border-radius: 50%;
    }

    .marker-cluster div {
      width: 36px;
      height: 36px;
      margin-left: 4px;
      margin-top: 4px;
      text-align: center;
      border-radius: 50%;
      font-size: 11px;
      font-weight: 600;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      line-height: 1.1;
    }

    .marker-cluster span {
      display: block;
    }

    .marker-cluster .cluster-people {
      font-size: 9px;
      font-weight: 400;
      opacity: 0.9;
    }

    /* Severity colors: green (few) -> amber (moderate) -> red (many) */
    .marker-cluster-small {
      background: rgba(74, 222, 128, 0.5);
    }
    .marker-cluster-small div {
      background: rgba(74, 222, 128, 0.9);
    }

    .marker-cluster-medium {
      background: rgba(251, 191, 36, 0.5);
    }
    .marker-cluster-medium div {
      background: rgba(251, 191, 36, 0.9);
    }

    .marker-cluster-large {
      background: rgba(248, 113, 113, 0.5);
    }
    .marker-cluster-large div {
      background: rgba(248, 113, 113, 0.9);
    }

    /* Border indicates unassigned ratio */
    .marker-cluster-mostly-assigned {
      box-shadow: 0 0 0 3px rgba(74, 222, 128, 0.7);
    }
    .marker-cluster-mixed {
      box-shadow: 0 0 0 3px rgba(251, 191, 36, 0.7);
    }
    .marker-cluster-mostly-unassigned {
      box-shadow: 0 0 0 3px rgba(248, 113, 113, 0.7);
    }

    /* Legend size indicators */
    .legend-marker-small {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #888;
      border: 2px solid #fff;
    }

    .legend-marker-medium {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #888;
      border: 2px solid #fff;
    }

    .legend-marker-large {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: #888;
      border: 2px solid #fff;
    }

    .legend-cluster {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: rgba(251, 191, 36, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: 600;
      color: #fff;
      box-shadow: 0 0 0 3px rgba(251, 191, 36, 0.5);
    }

    .legend-section {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid #333;
    }

    .legend-section-title {
      font-size: 0.7rem;
      color: #666;
      text-transform: uppercase;
      margin-bottom: 6px;
    }

    .legend-size-row {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    /* Mobile styles */
    @media (max-width: 768px) {
      header {
        padding: 12px 16px;
      }

      h1 {
        font-size: 1.2rem;
      }

      .auto-refresh label {
        display: none;
      }

      .metrics-row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px 16px;
      }

      .metrics-group {
        min-width: 0;
      }

      .address-input {
        width: 100%;
      }

      .metrics-values {
        gap: 4px;
        font-size: 0.8rem;
      }

      .divider {
        display: none;
      }

      .legend {
        bottom: 16px;
        left: 16px;
        padding: 8px 12px;
        font-size: 0.75rem;
      }
    }
  </style>
</head>
<body>
  <header>
    <div class="header-top">
      <h1>NES Outage Dashboard</h1>
      <div class="auto-refresh">
        <label for="autoRefresh">Auto-refresh</label>
        <div class="toggle">
          <input type="checkbox" id="autoRefresh" checked>
          <span class="toggle-slider"></span>
        </div>
      </div>
    </div>
    <div class="metrics-row">
      <div class="metrics-group address-group">
        <div class="metrics-label">Address</div>
        <div class="address-wrapper">
          <input type="text" id="inputAddress" placeholder="Default: 12 South Edley's" class="inline-input address-input" autocomplete="off">
          <div id="addressDropdown" class="address-dropdown hidden"></div>
        </div>
      </div>
      <div class="metrics-group">
        <div class="metrics-label">Radius</div>
        <div class="metrics-values">
          <input type="number" id="inputRadius" step="0.1" min="0.1" max="50" class="inline-input radius" value="1"> mi
        </div>
      </div>
      <div class="metrics-group">
        <div class="metrics-label">Nashville</div>
        <div class="metrics-values">
          <span><strong id="nashvilleEvents">0</strong> outages</span>
          <span class="divider">|</span>
          <span><strong id="nashvillePeople">0</strong> people</span>
        </div>
      </div>
      <div class="metrics-group">
        <div class="metrics-label">Nearby</div>
        <div class="metrics-values">
          <span><strong id="nearbyEvents">0</strong> outages</span>
          <span class="divider">|</span>
          <span><strong id="nearbyPeople">0</strong> people</span>
        </div>
      </div>
      <div class="metrics-group">
        <div class="metrics-label">Status</div>
        <div class="metrics-values">
          <span class="status-dot assigned"></span>
          <span><strong id="assignedCount">0</strong> assigned</span>
          <span class="divider">|</span>
          <span class="status-dot unassigned"></span>
          <span><strong id="unassignedCount">0</strong> unassigned</span>
        </div>
      </div>
      <div class="metrics-group">
        <div class="metrics-label">Resolving</div>
        <div class="metrics-values">
          <span><strong id="resolutionRate">--</strong>/hr</span>
        </div>
      </div>
      <div class="metrics-group">
        <div class="metrics-label">People (6hr)</div>
        <div class="metrics-values">
          <span id="netPeopleChange">--</span>
        </div>
      </div>
      <div class="metrics-group">
        <div class="metrics-label">Updated</div>
        <div class="metrics-values">
          <span id="lastUpdated">--:--</span>
        </div>
      </div>
    </div>
  </header>

  <div id="map"></div>

  <div class="legend">
    <div class="legend-item">
      <div class="legend-marker home"></div>
      <span>Home</span>
    </div>
    <div class="legend-item">
      <div class="legend-marker assigned"></div>
      <span>Assigned</span>
    </div>
    <div class="legend-item">
      <div class="legend-marker unassigned"></div>
      <span>Unassigned</span>
    </div>
    <div class="legend-section">
      <div class="legend-section-title">Marker Size</div>
      <div class="legend-item legend-size-row">
        <div class="legend-marker-small"></div>
        <div class="legend-marker-medium"></div>
        <div class="legend-marker-large"></div>
        <span>= people affected</span>
      </div>
    </div>
    <div class="legend-section">
      <div class="legend-section-title">Clusters</div>
      <div class="legend-item">
        <div class="legend-cluster">5</div>
        <span>Grouped outages</span>
      </div>
    </div>
  </div>

  <div class="loading" id="loading">
    <div class="spinner"></div>
    <div>Loading outages...</div>
  </div>

  <script>
    const STORAGE_KEY = 'nes-outage-settings';
    const REFRESH_INTERVAL_MS = 30000;

    let map;
    let homeMarker;
    let radiusCircle;
    let markerClusterGroup;
    let refreshInterval;
    let currentConfig = null;
    let serverDefaults = null;

    // Load settings from localStorage (returns null if invalid)
    function loadSettings() {
      const stored = localStorage.getItem(STORAGE_KEY);
      if (stored) {
        const settings = JSON.parse(stored);
        // Validate that we have actual coordinates
        if (settings.homeLat && settings.homeLng) {
          return settings;
        }
      }
      return null;
    }

    // Save settings to localStorage
    function saveSettings(settings) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
    }

    // Address search using Nominatim
    let addressSearchTimer;
    const addressInput = document.getElementById('inputAddress');
    const addressDropdown = document.getElementById('addressDropdown');

    async function searchAddress(query) {
      if (query.length < 3) {
        addressDropdown.classList.add('hidden');
        return;
      }

      try {
        const params = new URLSearchParams({
          q: query,
          format: 'json',
          limit: '5',
          addressdetails: '1',
          countrycodes: 'us',
          viewbox: '-88.0,36.7,-85.5,35.2',
          bounded: '1'
        });

        const response = await fetch(`https://nominatim.openstreetmap.org/search?${params}`, {
          headers: { 'User-Agent': 'NES-Outage-Dashboard' }
        });
        const results = await response.json();

        if (results.length === 0) {
          addressDropdown.classList.add('hidden');
          return;
        }

        addressDropdown.innerHTML = results.map(r => `
          <div class="address-option" data-lat="${r.lat}" data-lng="${r.lon}">
            <div class="address-option-main">${r.address?.house_number || ''} ${r.address?.road || r.name || ''}</div>
            <div class="address-option-secondary">${r.address?.city || r.address?.town || r.address?.village || ''}, ${r.address?.state || ''}</div>
          </div>
        `).join('');

        addressDropdown.classList.remove('hidden');
      } catch (e) {
        console.error('Address search failed:', e);
      }
    }

    addressInput.addEventListener('input', () => {
      clearTimeout(addressSearchTimer);
      addressSearchTimer = setTimeout(() => searchAddress(addressInput.value), 300);
    });

    addressDropdown.addEventListener('click', (e) => {
      const option = e.target.closest('.address-option');
      if (option) {
        const lat = parseFloat(option.dataset.lat);
        const lng = parseFloat(option.dataset.lng);
        addressInput.value = option.querySelector('.address-option-main').textContent.trim();
        addressDropdown.classList.add('hidden');
        onLocationChange(lat, lng);
      }
    });

    // Handle location changes from address selection
    function onLocationChange(lat, lng) {
      const radius = parseFloat(document.getElementById('inputRadius').value) || 1;
      const settings = { homeLat: lat, homeLng: lng, radiusMiles: radius };
      saveSettings(settings);
      currentConfig = null;
      fetchAndUpdateOutages();
    }

    // Hide dropdown when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.address-wrapper')) {
        addressDropdown.classList.add('hidden');
      }
    });

    // Populate inline inputs with current values
    function populateInputs() {
      const settings = loadSettings() || serverDefaults;
      if (settings) {
        document.getElementById('inputRadius').value = settings.radiusMiles || 1;
      }
    }

    // Get settings from stored values and radius input
    function getInputSettings() {
      const stored = loadSettings() || serverDefaults;
      if (!stored || !stored.homeLat || !stored.homeLng) {
        return null;
      }
      const radius = parseFloat(document.getElementById('inputRadius').value) || 1;
      return { homeLat: stored.homeLat, homeLng: stored.homeLng, radiusMiles: radius };
    }

    // Handle radius input changes
    function onRadiusChange() {
      const settings = getInputSettings();
      if (settings) {
        saveSettings(settings);
        currentConfig = null; // Force map reinitialize
        fetchAndUpdateOutages();
      }
    }

    // Initialize map
    function initMap(homeLat, homeLng) {
      if (map) {
        map.remove();
      }
      map = L.map('map').setView([homeLat, homeLng], 14);

      L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        maxZoom: 19
      }).addTo(map);

      homeMarker = null;
      radiusCircle = null;
      markerClusterGroup = null;
    }

    // Format number with abbreviation (e.g., 1200 -> "1.2k")
    function formatPeopleAbbrev(num) {
      if (num >= 1000) {
        return (num / 1000).toFixed(1) + 'k';
      }
      return num.toString();
    }

    // Create marker cluster group with custom styling
    function createClusterGroup() {
      return L.markerClusterGroup({
        maxClusterRadius: 50,
        spiderfyOnMaxZoom: true,
        showCoverageOnHover: false,
        zoomToBoundsOnClick: true,
        iconCreateFunction: function(cluster) {
          const childMarkers = cluster.getAllChildMarkers();
          const count = childMarkers.length;

          // Calculate totals from child markers
          let totalPeople = 0;
          let assignedCount = 0;
          childMarkers.forEach(marker => {
            totalPeople += marker.options.numPeople || 0;
            if (marker.options.isAssigned) assignedCount++;
          });

          // Determine severity class based on total people affected
          let sizeClass;
          if (totalPeople < 500) {
            sizeClass = 'marker-cluster-small';
          } else if (totalPeople < 2000) {
            sizeClass = 'marker-cluster-medium';
          } else {
            sizeClass = 'marker-cluster-large';
          }

          // Determine assignment ratio class
          const assignedRatio = assignedCount / count;
          let assignmentClass;
          if (assignedRatio > 0.7) {
            assignmentClass = 'marker-cluster-mostly-assigned';
          } else if (assignedRatio > 0.3) {
            assignmentClass = 'marker-cluster-mixed';
          } else {
            assignmentClass = 'marker-cluster-mostly-unassigned';
          }

          const peopleAbbrev = formatPeopleAbbrev(totalPeople);

          return L.divIcon({
            html: `<div><span>${count}</span><span class="cluster-people">${peopleAbbrev}</span></div>`,
            className: `marker-cluster ${sizeClass} ${assignmentClass}`,
            iconSize: L.point(44, 44)
          });
        }
      });
    }

    function createHomeMarker(lat, lng) {
      if (homeMarker) {
        map.removeLayer(homeMarker);
      }

      const homeIcon = L.divIcon({
        className: 'home-marker',
        html: `<div style="
          width: 20px;
          height: 20px;
          background: #3b82f6;
          border: 3px solid #fff;
          border-radius: 50%;
          box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        "></div>`,
        iconSize: [20, 20],
        iconAnchor: [10, 10]
      });

      homeMarker = L.marker([lat, lng], { icon: homeIcon })
        .addTo(map)
        .bindPopup('<div class="popup-title">Home</div>');
    }

    function createRadiusCircle(lat, lng, radiusMiles) {
      if (radiusCircle) {
        map.removeLayer(radiusCircle);
      }

      const radiusMeters = radiusMiles * 1609.34;
      radiusCircle = L.circle([lat, lng], {
        radius: radiusMeters,
        color: '#3b82f6',
        fillColor: '#3b82f6',
        fillOpacity: 0.1,
        weight: 2,
        dashArray: '5, 5'
      }).addTo(map);
    }

    function createOutageMarker(outage) {
      const isAssigned = outage.status === 'Assigned';
      const color = isAssigned ? '#4ade80' : '#f87171';

      // Size based on people affected using log scale (12px - 28px)
      const minSize = 12;
      const maxSize = 28;
      const numPeople = outage.numPeople || 1;
      // Log scale: 1 person = 12px, 10000+ = 28px
      const logScale = Math.log10(Math.max(1, numPeople));
      const maxLog = Math.log10(10000);
      const size = Math.min(maxSize, Math.max(minSize, minSize + (logScale / maxLog) * (maxSize - minSize)));
      const sizeRounded = Math.round(size);

      const icon = L.divIcon({
        className: 'outage-marker',
        html: `<div style="
          width: ${sizeRounded}px;
          height: ${sizeRounded}px;
          background: ${color};
          border: 2px solid #fff;
          border-radius: 50%;
          box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        "></div>`,
        iconSize: [sizeRounded, sizeRounded],
        iconAnchor: [sizeRounded / 2, sizeRounded / 2]
      });

      const statusClass = isAssigned ? 'assigned' : 'unassigned';
      const popupContent = `
        <div class="popup-title">Outage #${outage.id}</div>
        <div class="popup-row">
          <span class="popup-label">Status</span>
          <span class="popup-value ${statusClass}">${outage.status}</span>
        </div>
        <div class="popup-row">
          <span class="popup-label">People Affected</span>
          <span class="popup-value">${outage.numPeople.toLocaleString()}</span>
        </div>
        <div class="popup-row">
          <span class="popup-label">Distance</span>
          <span class="popup-value">${outage.distance.toFixed(2)} mi</span>
        </div>
        <div class="popup-row">
          <span class="popup-label">Last Updated</span>
          <span class="popup-value">${formatTimeAgo(outage.lastUpdated)}</span>
        </div>
        ${outage.cause ? `
        <div class="popup-row">
          <span class="popup-label">Cause</span>
          <span class="popup-value">${outage.cause}</span>
        </div>
        ` : ''}
        ${outage.estimatedRestoration ? `
        <div class="popup-row">
          <span class="popup-label">Est. Restoration</span>
          <span class="popup-value">${new Date(outage.estimatedRestoration).toLocaleTimeString()}</span>
        </div>
        ` : ''}
      `;

      // Store numPeople and isAssigned on marker options for cluster calculations
      const marker = L.marker([outage.lat, outage.lng], {
        icon,
        numPeople: outage.numPeople,
        isAssigned: isAssigned
      }).bindPopup(popupContent);

      return marker;
    }

    function formatTimeAgo(isoString) {
      const now = new Date();
      const updated = new Date(isoString);
      const diffMs = now.getTime() - updated.getTime();
      const diffMinutes = Math.floor(diffMs / 60000);

      if (diffMinutes < 1) return 'just now';
      if (diffMinutes < 60) return `${diffMinutes}m ago`;
      const diffHours = Math.floor(diffMinutes / 60);
      if (diffHours < 24) return `${diffHours}h ago`;
      const diffDays = Math.floor(diffHours / 24);
      return `${diffDays}d ago`;
    }

    function clearOutageMarkers() {
      if (markerClusterGroup) {
        markerClusterGroup.clearLayers();
      }
    }

    function updateStatusBar(outages, totals) {
      const assigned = outages.filter(o => o.status === 'Assigned').length;
      const unassigned = outages.filter(o => o.status !== 'Assigned').length;

      // Nashville totals
      if (totals?.nashville) {
        document.getElementById('nashvilleEvents').textContent = totals.nashville.events.toLocaleString();
        document.getElementById('nashvillePeople').textContent = totals.nashville.peopleAffected.toLocaleString();
      }

      // Nearby totals
      if (totals?.nearby) {
        document.getElementById('nearbyEvents').textContent = totals.nearby.events.toLocaleString();
        document.getElementById('nearbyPeople').textContent = totals.nearby.peopleAffected.toLocaleString();
      }

      // Status counts
      document.getElementById('assignedCount').textContent = assigned;
      document.getElementById('unassignedCount').textContent = unassigned;
      document.getElementById('lastUpdated').textContent = new Date().toLocaleTimeString();
    }

    async function fetchTrends() {
      try {
        const response = await fetch('/api/trends?hours=6');
        const data = await response.json();

        if (data.resolutionRate !== undefined) {
          document.getElementById('resolutionRate').textContent = data.resolutionRate.toFixed(1);
        }

        if (data.netPeopleChange !== undefined) {
          const change = data.netPeopleChange;
          const el = document.getElementById('netPeopleChange');
          if (change > 0) {
            el.innerHTML = `<span style="color: #f87171;">+${change.toLocaleString()}</span>`;
          } else if (change < 0) {
            el.innerHTML = `<span style="color: #4ade80;">${change.toLocaleString()}</span>`;
          } else {
            el.textContent = '0';
          }
        }
      } catch (e) {
        console.log('Trends not available');
      }
    }

    async function fetchAndUpdateOutages() {
      const settings = getInputSettings() || loadSettings();
      if (!settings) {
        document.getElementById('loading').style.display = 'none';
        return;
      }

      try {
        const params = new URLSearchParams({
          lat: settings.homeLat,
          lng: settings.homeLng,
          radius: settings.radiusMiles
        });

        const response = await fetch(`/api/outages?${params}`);
        const data = await response.json();

        if (data.error) {
          throw new Error(data.error);
        }

        // Initialize or update map if config changed
        const configChanged = !currentConfig ||
          currentConfig.homeLat !== data.config.homeLat ||
          currentConfig.homeLng !== data.config.homeLng ||
          currentConfig.radiusMiles !== data.config.radiusMiles;

        if (configChanged) {
          initMap(data.config.homeLat, data.config.homeLng);
          createHomeMarker(data.config.homeLat, data.config.homeLng);
          createRadiusCircle(data.config.homeLat, data.config.homeLng, data.config.radiusMiles);
          // Create marker cluster group
          markerClusterGroup = createClusterGroup();
          map.addLayer(markerClusterGroup);
          currentConfig = data.config;
        }

        clearOutageMarkers();

        data.outages.forEach(outage => {
          const marker = createOutageMarker(outage);
          markerClusterGroup.addLayer(marker);
        });

        updateStatusBar(data.outages, data.totals);
        document.getElementById('loading').style.display = 'none';
      } catch (error) {
        console.error('Failed to fetch outages:', error);
        document.getElementById('loading').innerHTML = `
          <div style="color: #f87171;">Failed to load outages</div>
          <div style="font-size: 0.8rem; margin-top: 8px; color: #888;">${error.message}</div>
        `;
      }
    }

    function startAutoRefresh() {
      if (refreshInterval) clearInterval(refreshInterval);
      refreshInterval = setInterval(() => {
        fetchAndUpdateOutages();
        fetchTrends();
      }, REFRESH_INTERVAL_MS);
    }

    function stopAutoRefresh() {
      if (refreshInterval) {
        clearInterval(refreshInterval);
        refreshInterval = null;
      }
    }

    // Event listeners - debounce input changes
    let debounceTimer;
    function debouncedRadiusChange() {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(onRadiusChange, 500);
    }

    document.getElementById('inputRadius').addEventListener('change', onRadiusChange);
    document.getElementById('inputRadius').addEventListener('input', debouncedRadiusChange);

    document.getElementById('autoRefresh').addEventListener('change', (e) => {
      if (e.target.checked) {
        startAutoRefresh();
      } else {
        stopAutoRefresh();
      }
    });

    // Initial load
    async function init() {
      // Fetch server defaults
      try {
        const response = await fetch('/api/config');
        const config = await response.json();
        if (config.homeLat && config.homeLng) {
          serverDefaults = {
            homeLat: config.homeLat,
            homeLng: config.homeLng,
            radiusMiles: config.radiusMiles || 1
          };
          // Auto-save server defaults if no local settings
          if (!loadSettings()) {
            saveSettings(serverDefaults);
          }
        }
      } catch (e) {
        // Server config not available
      }

      // Populate inputs with saved or default values
      populateInputs();

      fetchAndUpdateOutages();
      fetchTrends();
      startAutoRefresh();
    }

    init();
  </script>
</body>
</html>
